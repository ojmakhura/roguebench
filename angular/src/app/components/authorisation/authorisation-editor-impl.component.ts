// Generated by andromda-angular cartridge (view\components\component.ts.vsl) DO NOT EDIT
import { Component, effect, inject } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { SelectItem } from '@app/utils/select-item';
import { of } from 'rxjs';
import { CommonModule } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { MaterialModule } from '@app/material.module';
import { AccessPointListDTO } from '@app/model/bw/co/roguesystems/bench/access/access-point-list-dto';
import { AuthorisationEditorComponent } from './authorisation-editor.component';
import { TableComponent } from '@app/components/table/table.component';
import { AppEnvStore } from '@app/store/app-env.state';
import { AuthorisationApiStore } from '@app/store/bw/co/roguesystems/bench/authorisation/authorisation-api.store';
import { AccessPointApiStore } from '@app/store/bw/co/roguesystems/bench/access/access-point-api.store';
import { AuthorisationDTO } from '@app/model/bw/co/roguesystems/bench/authorisation/authorisation-dto';
import { AccessPointCriteria } from '@app/model/bw/co/roguesystems/bench/access/access-point-criteria';
import { MatAutocompleteSelectedEvent } from '@angular/material/autocomplete';

@Component({
  selector: 'app-authorisation-editor',
  templateUrl: './authorisation-editor.component.html',
  styleUrls: [],
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule, TranslateModule, MaterialModule, TableComponent],
})
export class AuthorisationEditorImplComponent extends AuthorisationEditorComponent {
  readonly appStore = inject(AppEnvStore);
  readonly authorisationApiStore = inject(AuthorisationApiStore);
  readonly accessPointApiStore = inject(AccessPointApiStore);
  realmRoles = this.appStore.realmRoles;
  loadingRoles = false;
  loadingAccessPoints = false;

  override rolesBackingList: SelectItem[] = [];

  constructor() {
    super();

    this.authorisationEditorForm.roles = [];

    effect(() => {
      if (!this.realmRoles) {
        return;
      }

      if (this.realmRoles) {
        let roles = this.realmRoles();

        if (roles) {
          this.rolesFilteredList$ = of(roles);
        }
      }
    });

    effect(() => {
      let authorisation = this.authorisationApiStore.data();

      if (!authorisation) {
        authorisation = new AuthorisationDTO();
      }

      if (authorisation) {
        this.authorisationEditorForm.id = authorisation.id;

        if (authorisation?.accessPoint?.id) {
          this.accessPointFilteredList$ = of([authorisation.accessPoint]);
        }

        this.authorisationEditorForm.roles = [];

        authorisation?.roles?.forEach((role: string) => {
          let item = new SelectItem();
          item.value = role;
          let label = this.rolesBackingList.find((r: SelectItem) => r.value === role)?.label;
          item.label = label ? label : role;

          this.authorisationEditorForm.roles?.push(item);
        });

        setTimeout(() => {
          this.formGroupControl.patchValue(authorisation);
        });
      }
    });

    effect(() => {
      this.accessPointBackingList = this.accessPointApiStore.dataList();
      if (this.loadingAccessPoints) {
        this.loadingAccessPoints = false;
        this.accessPointFilteredList$ = of(this.accessPointBackingList);
      }
    });

    effect(() => {
      this.rolesBackingList = this.appStore.realmRoles();
      this.rolesFilteredList$ = of(this.rolesBackingList);
    });
  }

  override ngAfterViewInit() {
    this.accessPointControl.valueChanges.subscribe((value) => {
      this.authorisationEditorForm.accessPoint = value;
    });

  }

  override rolesCompare(o1: any | any, o2: any | any) {
    return o1 && o2 ? o1.id === o2.id : false;
  }

  override filterAccessPoint(): void {
    this.loadingAccessPoints = true;
    let criteria: AccessPointCriteria = new AccessPointCriteria();
    criteria.name = this.accessPointFilterCtrl.value;
    criteria.type = this.accessPointFilterCtrl.value;
    criteria.url = this.accessPointFilterCtrl.value;
    this.accessPointApiStore.searchOr({ criteria });
  }

  override accessPointCompare(o1: AccessPointListDTO | any, o2: AccessPointListDTO | any) {
    return o1 && o2 ? o1.id === o2.id : false;
  }

  override rolesSelected(event: MatAutocompleteSelectedEvent): void {
    let item: SelectItem = event.option.value;
    console.log('item', item);

    let selected: any = {};

    this.authorisationEditorForm.roles?.forEach((role) => {
      selected[role.value] = role.label;
    });

    // If the UNSECURED role is selected, do not allow any other roles to be added
    if (selected['UNSECURED']) {
      alert('You cannot add any other roles when the UNSECURED role is selected.');
      return;
    }

    // If the UNSECURED role is not selected, remove all other roles and add the UNSECURED role
    if (
      this.authorisationEditorForm.roles?.length &&
      item.value === 'UNSECURED' &&
      confirm('Are you sure you want to add the UNSECURED role? This action will remove all other roles.')
    ) {
      this.authorisationEditorForm.roles = [];
      this.authorisationEditorForm.roles?.push(item);
    }

    this.authorisationEditorForm.roles?.push(event.option.value);
    this.setRolesControl();
    this.rolesChipControl.setValue(null);

    // remove the selected role from the list
    console.log('this.rolesBackingList', this.rolesBackingList);
    this.rolesBackingList = this.rolesBackingList.filter((role) => role.value !== item.value);
    console.log('this.rolesBackingList', this.rolesBackingList);
    this.rolesFilteredList$ = of(this.rolesBackingList);
  }
}
